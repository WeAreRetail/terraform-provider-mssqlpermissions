package queries

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"terraform-provider-mssqlpermissions/internal/queries/model"
)

// GetDatabaseRole retrieves a database role from the specified database.
// It takes a context, a database connection, and a database role model as input.
// It returns the retrieved database role model and an error if any.
func (c *Connector) GetDatabaseRole(ctx context.Context, db *sql.DB, databaseRole *model.Role) (*model.Role, error) {
	var err error

	// Check if the database connection is nil.
	if err := c.validateDatabaseConnection(ctx, db); err != nil {
		return nil, err
	}

	// SQL query to get a database role.
	query := `SELECT name, principal_id, type, type_desc, owning_principal_id, is_fixed_role
				FROM [sys].[database_principals]
				WHERE [name] = @name AND type_desc = 'DATABASE_ROLE'`

	// Execute the query and get a single row result.
	row := db.QueryRowContext(ctx, query, sql.Named("name", databaseRole.Name))

	// Check for any error during the query execution.
	if err = row.Err(); err != nil {
		return nil, fmt.Errorf("query execution error - cannot retrieve database role: %w", err)
	}

	// Scan the result into the DatabaseRole model.
	err = row.Scan(&databaseRole.Name, &databaseRole.PrincipalID, &databaseRole.Type, &databaseRole.TypeDescription, &databaseRole.OwningPrincipal, &databaseRole.IsFixedRole)

	// Check if the database role is not found.
	if err == sql.ErrNoRows {
		return nil, errors.New("database role not found")
	} else if err != nil {
		// Check for other scan errors.
		return nil, fmt.Errorf("scan error - cannot retrieve database role: %w", err)
	}

	return databaseRole, nil
}

// CreateDatabaseRole creates a new database role in the specified database.
// It takes a context, a database connection, and a database role model as input.
// It returns an error if any.
func (c *Connector) CreateDatabaseRole(ctx context.Context, db *sql.DB, databaseRole *model.Role) error {
	var err error

	// Check if the database connection is nil.
	if err := c.validateDatabaseConnection(ctx, db); err != nil {
		return err
	}

	// Create a copy of the database role to avoid mutating the input parameter
	roleCopy := *databaseRole

	// Check the provided PrincipalID. Defaulting to 1 if not provided.
	if roleCopy.PrincipalID == 0 {
		roleCopy.PrincipalID = 1
	}

	// Retrieve the user with the provided ID.
	user, err := c.GetUser(ctx, db, &model.User{PrincipalID: roleCopy.PrincipalID})
	if err != nil {
		return fmt.Errorf("cannot get user with PrincipalID equals to %d. Underlying error : %w", roleCopy.PrincipalID, err)
	}

	// SQL query to get a database role.
	query := "'CREATE ROLE ' + QUOTENAME(@database_role_name) + ' AUTHORIZATION ' + QUOTENAME(@user_name)"

	// The full TSQL script.
	tsql := fmt.Sprintf("DECLARE @sql NVARCHAR(MAX)\nSET @sql = %s;\nEXEC (@sql)", query)

	_, err = db.ExecContext(
		ctx,
		tsql,
		sql.Named("database_role_name", roleCopy.Name),
		sql.Named("user_name", user.Name))

	if err != nil {
		return fmt.Errorf("cannot create database role. Underlying sql error : %w", err)
	} else {
		return nil
	}
}

// DeleteDatabaseRole deletes a database role from the specified database.
// It takes a context, a database connection, and a database role model as input.
// It returns an error if any.
// Not available on Azure Database.
func (c *Connector) DeleteDatabaseRole(ctx context.Context, db *sql.DB, databaseRole *model.Role) error {
	var err error

	// Check if the database connection is nil.
	if err := c.validateDatabaseConnection(ctx, db); err != nil {
		return err
	}

	// The full TSQL script.
	// Adapted from the script generated by SSMS.
	tsql := `
	IF @RoleName <> N'public' and (select is_fixed_role from sys.database_principals where name = @RoleName) = 0
	BEGIN
		DECLARE @RoleMemberName sysname
		DECLARE Member_Cursor CURSOR FOR
		select [name]
		from sys.database_principals
		where principal_id in (
			select member_principal_id
			from sys.database_role_members
			where role_principal_id in (
				select principal_id
				FROM sys.database_principals where [name] = @RoleName AND type = 'R'))

		OPEN Member_Cursor;

		FETCH NEXT FROM Member_Cursor
		into @RoleMemberName

		DECLARE @SQL NVARCHAR(4000)

		WHILE @@FETCH_STATUS = 0
		BEGIN

			SET @SQL = 'ALTER ROLE '+ QUOTENAME(@RoleName,'[') +' DROP MEMBER '+ QUOTENAME(@RoleMemberName,'[')
			EXEC(@SQL)

			FETCH NEXT FROM Member_Cursor
			into @RoleMemberName
		END;

		CLOSE Member_Cursor;
		DEALLOCATE Member_Cursor;
	END;

	SET @SQL = 'DROP ROLE ' + QUOTENAME(@RoleName)
	EXEC(@SQL);
	`

	_, err = db.ExecContext(
		ctx,
		tsql,
		sql.Named("RoleName", databaseRole.Name))

	if err != nil {
		return fmt.Errorf("cannot delete database role. Underlying sql error : %w", err)
	} else {
		return nil
	}
}

// AddDatabaseRoleMember adds a user to a database role in the specified database.
// It takes a context, a database connection, a database role model, and a user model as input.
// It returns an error if any.
func (c *Connector) AddDatabaseRoleMember(ctx context.Context, db *sql.DB, databaseRole *model.Role, user *model.User) error {
	var err error

	// Check if the database connection is nil.
	if err := c.validateDatabaseConnection(ctx, db); err != nil {
		return err
	}

	// Validate the provided user.
	user, err = c.GetUser(ctx, db, user)
	if err != nil {
		return fmt.Errorf("cannot retrieve the user. Underlying error : %w", err)
	}

	// Validate the provided database role.
	databaseRole, err = c.GetDatabaseRole(ctx, db, databaseRole)
	if err != nil {
		return fmt.Errorf("cannot retrieve the database role. Underlying error : %w", err)
	}

	// Define the query to add the user to the database role.
	query := "'ALTER ROLE ' + QUOTENAME(@database_role_name) + ' ADD MEMBER ' + QUOTENAME(@user_name)"

	// The full TSQL script.
	tsql := fmt.Sprintf("DECLARE @sql NVARCHAR(MAX)\nSET @sql = %s;\nEXEC (@sql)", query)

	// Execute the query.
	_, err = db.ExecContext(ctx, tsql, sql.Named("database_role_name", databaseRole.Name), sql.Named("user_name", user.Name))

	if err != nil {
		return fmt.Errorf("cannot add user to database role. Underlying sql error : %w", err)
	} else {
		return nil
	}
}

// AddDatabaseRoleMembers adds users to a database role in the specified database.
// It takes a context, a database connection, a database role model, and a list of user models as input.
// It returns an error if any.
func (c *Connector) AddDatabaseRoleMembers(ctx context.Context, db *sql.DB, databaseRole *model.Role, user []*model.User) error {
	for _, u := range user {
		err := c.AddDatabaseRoleMember(ctx, db, databaseRole, u)
		if err != nil {
			return fmt.Errorf("cannot add user to database role. Underlying error : %w", err)
		}
	}
	return nil
}

// RemoveDatabaseRoleMember removes a user from a database role in the specified database.
// It takes a context, a database connection, a database role model, and a user model as input.
// It returns an error if any.
func (c *Connector) RemoveDatabaseRoleMember(ctx context.Context, db *sql.DB, databaseRole *model.Role, user *model.User) error {
	var err error

	// Check if the database connection is nil.
	if err := c.validateDatabaseConnection(ctx, db); err != nil {
		return err
	}

	// Validate the provided user.
	user, err = c.GetUser(ctx, db, user)
	if err != nil {
		return fmt.Errorf("cannot retrieve the user. Underlying error : %w", err)
	}

	// Validate the provided database role.
	databaseRole, err = c.GetDatabaseRole(ctx, db, databaseRole)
	if err != nil {
		return fmt.Errorf("cannot retrieve the database role. Underlying error : %w", err)
	}

	// Define the query to remove the user from the database role.
	query := "'ALTER ROLE ' + QUOTENAME(@database_role_name) + ' DROP MEMBER ' + QUOTENAME(@user_name)"

	// The full TSQL script.
	tsql := fmt.Sprintf("DECLARE @sql NVARCHAR(MAX)\nSET @sql = %s;\nEXEC (@sql)", query)

	// Execute the query.
	_, err = db.ExecContext(ctx, tsql, sql.Named("database_role_name", databaseRole.Name), sql.Named("user_name", user.Name))

	if err != nil {
		return fmt.Errorf("cannot remove user from database role. Underlying sql error : %w", err)
	} else {
		return nil
	}
}

// RemoveDatabaseRoleMembers removes users from a database role in the specified database.
// It takes a context, a database connection, a database role model, and a list of user models as input.
// It returns an error if any.
func (c *Connector) RemoveDatabaseRoleMembers(ctx context.Context, db *sql.DB, databaseRole *model.Role, user []*model.User) error {
	for _, u := range user {
		err := c.RemoveDatabaseRoleMember(ctx, db, databaseRole, u)
		if err != nil {
			return fmt.Errorf("cannot remove user from database role. Underlying error : %w", err)
		}
	}
	return nil
}

// GetDatabaseRoleMembers retrieves the members of a database role from the specified database.
// It takes a context, a database connection, and a database role model as input.
// It returns a list of database role members and an error if any.
func (c *Connector) GetDatabaseRoleMembers(ctx context.Context, db *sql.DB, databaseRole *model.Role) ([]*model.User, error) {
	var err error
	var users []*model.User

	type DatabasePrincipals struct {
		Name                   string
		PrincipalID            int64
		Type                   string
		TypeDesc               string
		DefaultSchemaName      sql.NullString
		SID                    string
		AuthenticationType     int
		AuthenticationTypeDesc string
		DefaultLanguageName    sql.NullString
	}

	// Check if the database connection is nil.
	if err := c.validateDatabaseConnection(ctx, db); err != nil {
		return nil, err
	}

	// Check if the database role is nil.
	if databaseRole == nil {
		return nil, errors.New("database role is nil")
	}

	// SQL query to get the members of a database role.
	query := `SELECT [name], [principal_id], [type], [type_desc], [default_schema_name], CONVERT(varchar(max), [sid], 1) as [sid], [authentication_type], [authentication_type_desc], [default_language_name]
				FROM [sys].[database_principals]
				WHERE principal_id IN (
					SELECT member_principal_id
					FROM [sys].[database_role_members]
					WHERE role_principal_id IN (
						SELECT principal_id
						FROM [sys].[database_principals]
						WHERE [name] = @name AND type_desc = 'DATABASE_ROLE'))`

	// Execute the query.
	rows, err := db.QueryContext(ctx, query, sql.Named("name", databaseRole.Name))
	if err != nil {
		return nil, fmt.Errorf("query execution error - cannot retrieve database role members: %w", err)
	}
	defer func() {
		if closeErr := rows.Close(); closeErr != nil {
			fmt.Printf("error closing rows: %v\n", closeErr)
		}
	}()

	// Check for any error during the query execution.
	if err = rows.Err(); err != nil {
		return nil, fmt.Errorf("query execution error - cannot retrieve database role members: %w", err)
	}

	// Scan the result into the DatabaseRole model.
	for rows.Next() {
		var result DatabasePrincipals

		err = rows.Scan(
			&result.Name,
			&result.PrincipalID,
			&result.Type,
			&result.TypeDesc,
			&result.DefaultSchemaName,
			&result.SID,
			&result.AuthenticationType,
			&result.AuthenticationTypeDesc,
			&result.DefaultLanguageName)
		if err != nil {
			return nil, fmt.Errorf("scan error - cannot retrieve database role members: %w", err)
		}

		user := &model.User{
			Name: result.Name,
		}

		user, err = c.GetUser(ctx, db, user)
		if err != nil {
			return nil, fmt.Errorf("cannot retrieve the user. Underlying error : %w", err)
		}

		users = append(users, user)
	}

	// Return the retrieved database role members.
	if err != nil {
		return nil, fmt.Errorf("cannot retrieve database role members. Underlying sql error : %w", err)
	} else {
		return users, nil
	}
}
